// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: config_values.sql

package database

import (
	"context"
	"database/sql"
	"strings"
)

const deleteConfig = `-- name: DeleteConfig :one
DELETE FROM config_values
WHERE scope = ? AND key = ?
RETURNING scope, "key", value, type, is_sensitive, constraints, created_at, updated_at
`

type DeleteConfigParams struct {
	Scope string `json:"scope"`
	Key   string `json:"key"`
}

func (q *Queries) DeleteConfig(ctx context.Context, arg DeleteConfigParams) (ConfigValue, error) {
	row := q.db.QueryRowContext(ctx, deleteConfig, arg.Scope, arg.Key)
	var i ConfigValue
	err := row.Scan(
		&i.Scope,
		&i.Key,
		&i.Value,
		&i.Type,
		&i.IsSensitive,
		&i.Constraints,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConfig = `-- name: GetConfig :one
SELECT scope, "key", value, type, is_sensitive, constraints, created_at, updated_at FROM config_values
WHERE scope = ? AND key = ?
`

type GetConfigParams struct {
	Scope string `json:"scope"`
	Key   string `json:"key"`
}

func (q *Queries) GetConfig(ctx context.Context, arg GetConfigParams) (ConfigValue, error) {
	row := q.db.QueryRowContext(ctx, getConfig, arg.Scope, arg.Key)
	var i ConfigValue
	err := row.Scan(
		&i.Scope,
		&i.Key,
		&i.Value,
		&i.Type,
		&i.IsSensitive,
		&i.Constraints,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConfigs = `-- name: GetConfigs :many
SELECT scope, "key", value, type, is_sensitive, constraints, created_at, updated_at FROM config_values
WHERE scope = ?
  AND (key IN (/*SLICE:keys*/?) OR /*SLICE:keys*/? IS NULL)
`

type GetConfigsParams struct {
	Scope string   `json:"scope"`
	Keys  []string `json:"keys"`
}

func (q *Queries) GetConfigs(ctx context.Context, arg GetConfigsParams) ([]ConfigValue, error) {
	query := getConfigs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Scope)
	if len(arg.Keys) > 0 {
		for _, v := range arg.Keys {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:keys*/?", strings.Repeat(",?", len(arg.Keys))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:keys*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ConfigValue
	for rows.Next() {
		var i ConfigValue
		if err := rows.Scan(
			&i.Scope,
			&i.Key,
			&i.Value,
			&i.Type,
			&i.IsSensitive,
			&i.Constraints,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConfigKeys = `-- name: ListConfigKeys :many
SELECT scope, "key", value, type, is_sensitive, constraints, created_at, updated_at FROM config_values
WHERE scope = ?
  AND (key LIKE ? || '%' OR ? = '')
`

type ListConfigKeysParams struct {
	Scope   string         `json:"scope"`
	Column2 sql.NullString `json:"column_2"`
	Column3 interface{}    `json:"column_3"`
}

func (q *Queries) ListConfigKeys(ctx context.Context, arg ListConfigKeysParams) ([]ConfigValue, error) {
	rows, err := q.db.QueryContext(ctx, listConfigKeys, arg.Scope, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ConfigValue
	for rows.Next() {
		var i ConfigValue
		if err := rows.Scan(
			&i.Scope,
			&i.Key,
			&i.Value,
			&i.Type,
			&i.IsSensitive,
			&i.Constraints,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setConfig = `-- name: SetConfig :one
INSERT INTO config_values (scope, key, value, type, is_sensitive, constraints, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(scope, key) DO UPDATE SET
  value = excluded.value,
  type = excluded.type,
  is_sensitive = excluded.is_sensitive,
  constraints = excluded.constraints,
  updated_at = excluded.updated_at
RETURNING scope, "key", value, type, is_sensitive, constraints, created_at, updated_at
`

type SetConfigParams struct {
	Scope       string         `json:"scope"`
	Key         string         `json:"key"`
	Value       string         `json:"value"`
	Type        int64          `json:"type"`
	IsSensitive int64          `json:"is_sensitive"`
	Constraints sql.NullString `json:"constraints"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
}

func (q *Queries) SetConfig(ctx context.Context, arg SetConfigParams) (ConfigValue, error) {
	row := q.db.QueryRowContext(ctx, setConfig,
		arg.Scope,
		arg.Key,
		arg.Value,
		arg.Type,
		arg.IsSensitive,
		arg.Constraints,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ConfigValue
	err := row.Scan(
		&i.Scope,
		&i.Key,
		&i.Value,
		&i.Type,
		&i.IsSensitive,
		&i.Constraints,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
